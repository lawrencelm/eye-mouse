<html lang="en">
    <head>
    	<meta charset="utf-8">
    	<title>Camgaze.js</title>
    	<meta name="viewport" content="width=device-width, initial-scale=1.0">
    	<meta name="description" content="">
    	<meta name="author" content="">
    	<style type="text/css">
           #eye-mouse-cursor {
              height:5px;
              width:5px;
              position:fixed;
              background-color:#0f0;
              left:500px;
              z-index:1000;
            }       	
            body {
              padding-top: 60px;
              padding-bottom: 40px;
            }
              
            .container-narrow {
              margin: 0 auto;
              max-width: 700px;
            }

            div#badge {
                width: 141px;
                height: 141px;
                position: fixed;
                top: 0;
                right: 0;
            }
            #content {
              height:50%;
            }
            canvas, video{
              display:none;
              //visibility:hidden;
            }
            a {
              font-size:64pt;
              width:200px;
              height:50px;
              background-color:#00f;
            }
    	</style>
    	<!-- Le Bootstrap styles -->
        <link href="bootstrap-combined.min.css" rel="stylesheet">
    	<!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
        <!--[if lt IE 9]>
          <script src="js/html5shiv.js"></script>
          <![endif]-->
<!--
        <link type="text/css" rel="stylesheet" href="chrome-extension://cpngackimfmofbokmjmljamhdncknpmg/style.css">
        <script type="text/javascript" charset="utf-8" src="chrome-extension://cpngackimfmofbokmjmljamhdncknpmg/page_context.js"></script> -->
    </head>

    <body screen_capture_injected="true">
    <div id="eye-mouse-cursor"></div>
        <div align="center">
          <div class="container">
            <div id="content"> 
              <a name="zero"></a>
              <a href="#one"> CLICK ME IF YOU CAN </a>
            </div>
            <canvas id="eye-mouse-video"></canvas>
            <video style="display: none; " autoplay></video>
            <a name="one"></a>
            <a href="#zero"> AND ME TOO!!!! </a>
          </div>
        </div>

		<!-- JQuery and Bootstrap Javascript files -->
		<script src="jquery.min.js" ></script>

		<!-- Concuss.js and Canvas utilities -->
		<script text="text/javascript" src="build/jsfeat.js"></script>
		<script text="text/javascript" src="build/compatibility.js"></script>
		<script text="text/javascript" src="build/camgaze.js"></script>
		<script text="text/javascript" src="cascades/eye.js"></script>
		<script text="text/javascript" src="cascades/frontalface.js"></script>
		<script text="text/javascript" src="mouse-sim.js"></script>
		<script text="text/javascript">
			window.onload = function () {
				var height = 480;
				var width = 640;
        //var drawPt;
				var cGaze = new camgaze.Camgaze(
					width, 
					height, 
					"eye-mouse-video"
				);
        var eye_movement_max = 20;
				var eyeTracker = new camgaze.EyeTracker(width, height);
				var eyeFilter = new camgaze.EyeFilter();
				//var drawer = new camgaze.drawing.ImageDrawer();
        //var mappedMovingAverage = new camgaze.structures.MovingAveragePoints( new camgaze.structures.Point(0,0), 10);
        var runningAvg = new Array();
        var lftAvg = new Array();
        var rtAvg = new Array();
        var lwink_counter = 0;
        var rwink_counter = 0;
        var wink_threshold = 10;
        for (var i = 0; i < 5; i++) runningAvg.push(new camgaze.structures.Point(-1,-1));
        for (var i = 0; i < 5; i++) lftAvg.push(new camgaze.structures.Point(-1,-1));
        for (var i = 0; i < 5; i++) rtAvg.push(new camgaze.structures.Point(-1,-1));
        function average(pts) {
          xsum = 0; ysum = 0;
          for (var i = 0; i < pts.length; i++) {
            xsum += pts[i].getX();
            ysum += pts[i].getY();
          }
          return new camgaze.structures.Point(xsum/pts.length, ysum/pts.length);
        }
        function reasonable_eye_pos(left, right) {
          if (!calibrating)
            return (Math.abs(left.getY() - right.getY()) < eye_movement_max);
          else
            return true;
        }
       
        var calibrating = true;

        function isCalibrated() {
          if (calibrating) {
            for (var i = 0; i < runningAvg.length; i++) {
              if (runningAvg[i].getX() < 0 || runningAvg[i].getY() < 0 ||
                  lftAvg[i].getX() < 0 || lftAvg[i].getY() < 0 ||
                  rtAvg[i].getX() < 0 || rtAvg[i].getY() < 0) 
                return false;
            }
          }
          if (calibrating) {
            set_gaze_center(average(runningAvg));
            console.log (" CALIBRATED!!! ");
          }
          calibrating = false;
          return true;
        }

        function reCalibrate() {
          for (var i = 0; i < runningAvg.length; i++) {
            runningAvg[i] = new camgaze.structures.Point(-1, -1);
            lftAvg[i] = new camgaze.structures.Point(-1, -1);
            rtAvg[i] = new camgaze.structures.Point(-1, -1);
          }
          calibrating = true;
        }

				var frameOp = function (image_data, video) {
          var lookingPt;
					var trackingData = eyeTracker.track(image_data, video);
					var gazeList = eyeFilter.getFilteredGaze(trackingData);
                    // new HAAR.Detector(haarcascade_frontalface_alt, Parallel)
                    //                     .image(image_data) // use the image
                    //                     .interval(30) // set detection interval for asynchronous detection (if not parallel)
                    //                     .complete(function(){  // onComplete callback
                    //                         console.log(this.Selection, this.objects);
                    //                         alert(l+" Objects found");
                    //                     })
                    //                     .detect(1, 1.25, 0.1, 1, true); // go
          
					if (trackingData.eyeList.length == 2 && gazeList[0] != undefined && gazeList[1] != undefined) {
            lwink_counter = 0;
            rwink_counter = 0;
            //image_data = drawer.drawCircle(drawPt, 10, -1, "green");
            gazeList = eyeFilter.getFilteredGaze(trackingData);
            var lft_eye = gazeList[0].centroid.unfiltered;
            var rt_eye = gazeList[1].centroid.unfiltered;
            if (reasonable_eye_pos(lft_eye, rt_eye)) {
              if (lft_eye.getX() > rt_eye.getX()) {
                var tmp = lft_eye;
                lft_eye = rt_eye;
                rt_eye = tmp;
              }
              var ctr_eye = lft_eye.add(rt_eye);
              runningAvg.push(new camgaze.structures.Point(ctr_eye.getX()/2, ctr_eye.getY()/2));
              runningAvg.shift();

              lftAvg.push(lft_eye);
              lftAvg.shift();

              rtAvg.push(rt_eye);
              rtAvg.shift();

              var eyeCenter = average(runningAvg);
              //image_data = drawer.drawCircle(image_data, eyeCenter, 5, -1, "green");
              //image_data = drawer.drawCircle(image_data, average(lftAvg), 5, -1, "red");
              //image_data = drawer.drawCircle(image_data, average(rtAvg), 5, -1, "red");
              if (isCalibrated())
                move_from_centroid(eyeCenter);
            }
          } else if (trackingData.eyeList.length == 1 && gazeList[0] != undefined) {
            //console.log("WINK!");
            var winkEye = gazeList[0].centroid.unfiltered;
            var lft_eye = average(lftAvg);
            var rt_eye = average(rtAvg);
            if (winkEye.distTo(lft_eye) < winkEye.distTo(rt_eye)) {
              lwink_counter++; rwink_counter = 0;
              if (lwink_counter == wink_threshold) wink("left");
            } else {
              rwink_counter++; lwink_counter = 0;
              if (rwink_counter == wink_threshold) wink("right");
            }
          }
					return image_data;
				};
				cGaze.setFrameOperator(frameOp);
			} 
		</script>
	</body>
</html>

